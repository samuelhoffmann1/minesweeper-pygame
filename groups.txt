MineGroup.py

import math
import itertools
from dataclasses import dataclass
from settings import *
from sprites import *

from main import Game

class MineGroup:
    ''' A MineGroup is a set of cells that are known
    to have a certain number of mines.
    For example "cell1, cell2, cell3 have exactly 2 mine" or
    "cell4, cell5 have at least 1 mine".
    This is a basic element for Groups and Subgroups solving methods.
    '''

    def __init__(self, cells, mines, group_type="exactly"):
        ''' Cells in questions. Number of mines that those cells have.
        '''
        # Use set rather than list as it speeds up some calculations
        self.cells = set(cells)
        self.mines = mines

        # Group type ("exactly", "no more than", "at least")
        self.group_type = group_type

        # Calculate hash (for deduplication)
        self.hash = self.calculate_hash()

        # Placeholder for cluster belonging info
        # Mine group is a building block for group clusters.
        # belongs_to_cluster will have the cluster this group belongs to
        self.belongs_to_cluster = None

    def is_all_safe(self):
        ''' If group has 0 mines, all its cells are safe
        '''
        return self.mines == 0

    def is_all_mines(self):
        ''' If group has as many cells as mines - all cells are mines
        '''
        return len(self.cells) == self.mines

    def calculate_hash(self):
        ''' Hash of a group. To check if such group is already in self.group
        '''
        # Prepare data for hashing: sort cells, add self.mines
        for_hash = sorted(list(self.cells)) + [self.mines] + [self.group_type]
        # Make immutable
        for_hash = tuple(for_hash)
        # Return hash
        return hash(for_hash)

    def __str__(self):
        ''' List cells, mines and group type
        '''
        out = f"Cell(s) ({len(self.cells)}) "
        out += ",".join([str(cell) for cell in self.cells])
        out += f" have {self.group_type} {self.mines} mines"
        return out


class AllGroups:
    ''' Functions to handle a group of MineGroup object (groups and subgroups):
    deduplicate them, generate subgroups ("at least" and "no more than") etc
    '''

    def __init__(self):
        # Hashes of current groups. For deduplication
        self.hashes = set()
        # List of MineGroups
        self.mine_groups = []

        # self.mine_groups will be holding both groups ("exactly") and
        # subgroups ("at least", "no more than") - it is easier to generate
        # subgroups this way.
        # self.count_groups is a count of regular ("exactly") groups.
        # Used to save time iterating only through groups or subgroups.
        self.count_groups = None

        # Frontier: list of cells that belong to at least ong group
        self.frontier = []

    def reset(self):
        ''' Clear the data of the groups
        '''
        self.hashes = set()
        self.mine_groups = []
        # For some reason result is 0.1% better if I don't reset count_groups
        # It does not make sene to me, I can't find why. But so be it.
        # self.count_groups = None
        self.frontier = []

    def reset_clusters(self):
        ''' Clear "belong to cluster" for each group.
        '''
        for group in self.mine_groups:
            group.belong_to_cluster = None

    def next_non_clustered_groups(self):
        ''' Return a group, that is not a part of any cluster
        '''
        for group in self.mine_groups:
            if group.belong_to_cluster is None and \
               group.group_type == "exactly":
                return group
        return None

    def add_group(self, new_group):
        ''' Check if this group has been added already.
        If not, add to the list.
        '''
        if new_group.hash not in self.hashes:
            self.mine_groups.append(new_group)
            self.hashes.add(new_group.hash)

    def generate_frontier(self):
        ''' Populate self.frontier - list of cells belonging to any group
        '''
        frontier = set()
        for group in self:
            for cell in group.cells:
                frontier.add(cell)
        self.frontier = list(frontier)

    def __iter__(self):
        ''' Iterator for the groups
        '''
        return iter(self.mine_groups)

    def exact_groups(self):
        ''' Iterator, but only "exactly" groups
        '''
        return itertools.islice(self.mine_groups, self.count_groups)

    def subgroups(self):
        ''' Iterator, but only subgroups ("at least", "no more than")
        '''
        return itertools.islice(self.mine_groups,
                                self.count_groups, len(self.mine_groups))

    def generate_subgroup_at_least(self):
        ''' Generate "group has at least X mines" subgroup. Add them to groups.
        Done by removing a cell and a mine, in whichever groups it is possible.
        For example, if cell1, cell2, cell3 have 2 mines, than  cell1 and cell2
        have at least 1 mine, so are cell2 and cell3, cell3 and cell1.
        '''
        for group in self:

            # Doing it for cells in the middle of nowhere would take a lot of
            # resources but virtually never useful.
            if len(group.cells) > 7:
                continue

            # Group should have 3>2 cells and > 1 mines
            # And  be either "exactly" or "at least" group
            if len(group.cells) > 2 and group.mines > 1 and \
               group.group_type in ("exactly", "at least"):

                # Remove each cell and one mine - those  are your new subgroups
                for cell in group.cells:
                    new_subgroup = MineGroup(group.cells.difference({cell}),
                                             group.mines - 1, "at least")
                    # They will be added to the end of the list, so they
                    # in turn will be broken down, if needed
                    self.add_group(new_subgroup)

    def generate_subgroup_no_more_than(self):
        ''' Generate a second type of subgroups: "no more than", also add
        to the group. This one done by removing cells until there are mines+1
        left. For example, cell1 cell2, cell3 have 1 mine, which means that
        cell1 and cell2 have no more than 1 mine.
        '''
        for group in self:

            # Same here, no use  doing it to lonely cells out there
            if len(group.cells) > 7:
                continue

            # Here we need >2 cells and >0 mines to create  subgroups
            if len(group.cells) > 2 and group.mines > 0 and \
               group.group_type in ("exactly", "no more than"):

                for cell in group.cells:
                    new_subgroup = MineGroup(group.cells.difference({cell}),
                                             group.mines, "no more than")
                    self.add_group(new_subgroup)

    def __str__(self):
        ''' Some info about the groups (for debugging)
        '''
        return f"MineGroups contains {len(self.mine_groups)} groups"


# This method used for solving clusters and for brute force probabilities,
# So it is outside of classes
def all_mines_positions(cells_count, mines_to_set):
    ''' Generate all permutations for "mines_to_set" mines to be in
    "cells_count" cells.
    Result is a list of tuples like (False, False, True, False),
    indicating if the item was chosen (if there is a mine in the cell).
    For example, for generate_mines_permutations(2, 1) the output is:
    [(True, False), (False, True)]
    '''

    def recursive_choose_generator(current_combination, mines_to_set):
        ''' Recursive part of "Choose without replacement" permutation
        generator, results are put into outside "result" variable
        '''
        # No mines to set: save results, out of the recursion
        if mines_to_set == 0:
            result.add(tuple(current_combination))
            return

        for position, item in enumerate(current_combination):
            # Find all the "False" (not a mine) cells
            if not item:
                # Put a mine in it, go to the next recursion level
                current_copy = current_combination.copy()
                current_copy[position] = True
                recursive_choose_generator(current_copy, mines_to_set - 1)

    result = set()
    all_cells_false = [False for _ in range(cells_count)]
    recursive_choose_generator(all_cells_false, mines_to_set)
    return result


class GroupCluster:
    ''' GroupCluster are several MineGroups connected together. All groups
    overlap at least with one other groups o  mine/safe in any of the cell
    can potentially trigger safe/mine in any other cell of the cluster.
    Is a basic element for CSP method
    '''

    def __init__(self, group=None):
        # Cells in the cluster (as a set)
        self.cells_set = set()
        # List if groups in the cluster
        self.groups = []

        # Initiate by adding the first group
        if group is not None:
            self.add_group(group)

        # Placeholder for a list of cells (same as self.cells_set, but list).
        # We use both set and list because set is better for finding overlap
        # and list is needed to solve cluster.
        self.cells = []

        # Placeholder for the solutions of this CSP
        # (all valid sets of mines and safe cells)
        # Positions corresponds to self.cells
        self.solutions = []

        # Placeholder for the resulting frequencies of mines in each cell
        self.frequencies = {}

        # Placeholder for solution weight - how probable is this solution
        # based on the number of mines in it
        self.solution_weights = []

        # Dict of possible mine counts {mines: mine_count, ...}
        self.probable_mines = {}

        # Dict that holds information about "next safe" cells. How many
        # guaranteed safe cells will be in the cluster if "cell" is
        # clicked (and discovered to be safe)
        self.next_safe = {}

    def add_group(self, group):
        ''' Adding group to a cluster (assume they overlap).
        Add group's cells to the set of cells
        Also, mark the group as belonging to this cluster
        '''
        # Total list of cells in the cluster (union of all groups)
        self.cells_set = self.cells_set.union(group.cells)
        # List of groups belonging to the cluster
        self.groups.append(group)
        # Mark the group that it has been used
        group.belong_to_cluster = self

    def overlap(self, group):
        ''' Check if cells in group overlap with cells in the cluster.
        '''
        return len(self.cells_set & group.cells) > 0

    def solve_cluster(self, remaining_mines):
        ''' Use CSP to find the solution to the CSP. Solution is the list of
        all possible mine/safe variations that fits all groups' condition.
        Solution is in the form of a list of Tru/False (Tru for mine,
        False for safe), with positions in the solution corresponding to cells
        in self.cells list. Solution will be stored in self.solutions
        Will result in empty solution if the initial cluster is too big.
        '''
        # for clusters with 1 group - there is not enough data to solve them
        # if len(self.groups) == 1:
        #     return

        # It gets too slow and inefficient when
        # - There are too many, but clusters but not enough groups
        #    (cells/clusters > 12)
        # - Long clusters (>40 cells)
        # - Groups with too many possible mine positions (> 1001)
        # Do not solve such clusters
        if len(self.cells_set) / len(self.groups) > 12 or \
           len(self.cells_set) > 50 or \
           max(math.comb(len(group.cells), group.mines)
                for group in self.groups if group.mines > 0) > 1001:
            return

        # We need to fix the order of cells, for that we populate self.cells
        self.cells = list(self.cells_set)

        # We also need a way to find a position of each cell by
        # the cell itself. So here's the addressing dict
        cells_positions = {cell: pos for pos, cell in enumerate(self.cells)}

        # The list to put all the solutions in.
        # Each "solution" is a list of [True, False, None, ...],
        # corresponding to cluster's ordered cells,
        # where True is a mine, False is safe and None is unknown
        # It starts with all None and will be updated for each group
        solutions = [[None for _ in range(len(self.cells))], ]

        for group in self.groups:

            # List of all possible ways mines can be placed in
            # group's cells: for example: [(False, True, False), ...]
            mine_positions = all_mines_positions(len(group.cells),
                                                 group.mines)
            # Now the same, but with cells as keys
            # For example: {cell1: False, cell2: True, cell3: False}
            mine_positions_dict = [dict(zip(group.cells, mine_position))
                                   for mine_position in mine_positions]

            # Failsafe: if there are more than 1_000_000 combinations
            # to go through - pull the plug
            if len(solutions) * len(mine_positions) > 1_000_000:
                return

            # This is where will will put solutions,
            # updated with current group's conditions
            updated_solutions = []

            # Go through each current solution and possible
            # mine distribution in a group
            for solution in solutions:
                for mine_position in mine_positions_dict:

                    updated_solution = solution.copy()

                    # Check if this permutation fits with this solution
                    for cell in group.cells:
                        # This is the position of this cell in the solution
                        position = cells_positions[cell]
                        # If solution has nothing about this cell,
                        # just update it with cell data
                        if updated_solution[position] is None:
                            updated_solution[position] = mine_position[cell]
                        # But if there is already mine or safe in the solution:
                        # it should be the same as in the permutation
                        # If it isn't: break to the next permutation
                        elif updated_solution[position] != mine_position[cell]:
                            break
                    # If we didn't break (solution and permutation fits),
                    # Add it to the next round
                    else:
                        updated_solutions.append(updated_solution)

            solutions = updated_solutions

        # Check if there are no more mines in solutions than remaining mines
        for solution in solutions:
            mine_count = sum(1 for mine in solution if mine)
            if mine_count <= remaining_mines:
                self.solutions.append(solution)

    def calculate_frequencies(self):
        ''' Once the solution is there, we can calculate frequencies:
        how often is a cell a mine in all solutions. Populates the
        self.frequencies with a dict {cell: frequency, ... },
        where frequency ranges from 0 (100% safe) to 1 (100% mine).
        Also, use weights  (self.solution_weights) - it shows in how many
        cases this solution is likely to appear.
        '''
        # Can't do anything if there are no solutions
        if not self.solutions:
            return

        for position, cell in enumerate(self.cells):
            count_mines = 0
            for solution_n, solution in enumerate(self.solutions):
                # Mine count takes into account the weight of the solution
                # So if fact it is 1 * weight
                if solution[position]:
                    count_mines += self.solution_weights[solution_n]
            # Total in this case - not the number of solutions,
            # but weight of all solutions
            if sum(self.solution_weights) > 0:
                self.frequencies[cell] = count_mines / \
                    sum(self.solution_weights)
            # This shouldn't normally happen, but it may rarely happen during
            # "next move" method, when "Uncovered but unknown" cell is added
            else:
                self.frequencies[cell] = 0

    def calculate_next_safe(self):
        ''' Populate self.next_safe, how many guaranteed safe cells
        will be there next move, after clicking this cell.
        '''
        # Result will be here as {cell: next_safe_count}
        next_safe = {}

        # Go through all cells, we'll calculate next_safe for each
        for next_cell_position, next_cell in enumerate(self.cells):
            # Counter of next_safe
            next_safe_counter = 0

            # Go through all cells
            for position, _ in enumerate(self.cells):
                # Ignore itself (the cell we are counting the next_safe_for)
                if position == next_cell_position:
                    continue
                # Now look at all solutions
                for solution in self.solutions:
                    # Skip the solutions where next_cell is a mine
                    if solution[next_cell_position]:
                        continue
                    # If any solution has a mine in "position" -
                    # it will not be safe in the next move
                    if solution[position]:
                        break
                # But if you went through all solutions and all are safe:
                # this is the a cell that will be safe next move
                else:
                    next_safe_counter += 1
            # After looking at all positions we have the final count
            next_safe[next_cell] = next_safe_counter

        self.next_safe = next_safe

    def safe_cells(self):
        ''' Return list of guaranteed safe cells (0 in self.frequencies)
        '''
        safe = [cell for cell, freq in self.frequencies.items() if freq == 0]
        return safe

    def mine_cells(self):
        '''Return list of guaranteed mines (1 in self.frequencies)
        '''
        mines = [cell for cell, freq in self.frequencies.items() if freq == 1]
        return mines

    def calculate_solution_weights(self, covered_cells, remaining_mines):
        ''' Calculate how probable each solution  is,
        if there are total_mines left in the field. That is,
        how many combinations of mines are possible with this solution.
        Populate self.solution_weights with the results
        '''
        self.solution_weights = []

        # For each solution we calculate how  many combination are possible
        # with the remaining mines on the remaining cells
        for solution in self.solutions:
            solution_mines = sum(1 for mine in solution if mine)
            solution_comb = math.comb(len(covered_cells) - len(solution),
                                      remaining_mines - solution_mines)
            self.solution_weights.append(solution_comb)

    def possible_mine_counts(self):
        ''' Based on solution and weights, calculate a dict with possible
        mine counts. For example, {3: 4, 2: 1},  4 solutions with 3 mines,
        1 solution with 2. Put it in self.probable_mines
        Will be used for CSP Leftovers probability calculation.
        '''

        # Cluster was solved
        if self.solutions:
            # Look at each solution
            for solution in self.solutions:
                mines_count = sum(1 for position in solution if position)
                if mines_count not in self.probable_mines:
                    self.probable_mines[mines_count] = 0
                self.probable_mines[mines_count] += 1
            return

        # If cluster wasn't solved (which is basically never happens
        # on 2D field, but can happen at higher dimensions):
        cells_mine_probabilities = {}
        for group in self.groups:

            # Probability of mines for each cell in this group
            groups_probability = group.mines / len(group.cells)

            for cell in group.cells:
                # Put together a list of all probabilities
                if cell not in cells_mine_probabilities:
                    cells_mine_probabilities[cell] = []
                cells_mine_probabilities[cell].append(groups_probability)

        # Result is the sum of all averages
        total_mines = 0
        for cell, probabilities in cells_mine_probabilities.items():
            total_mines += sum(probabilities) / len(probabilities)
        self.probable_mines[int(total_mines)] = 1

    def mines_in_cells(self, cells_to_look_at):
        '''Calculate mine chances in only these particular cells
        '''
        # We need to calculate the dict of mine counts and their probability
        # like this: {0: 0.2, 1: 0.3, 2: 0.5}
        mine_counts = {}

        # Go through all solution and their weights
        for solution, weight in zip(self.solutions, self.solution_weights):

            # Calculate mines in cells_to_look_at for each solution
            mine_count = 0
            for position, cell in enumerate(self.cells):
                if cell in cells_to_look_at and solution[position]:
                    mine_count += 1

            # Accumulate weights for each mine count
            mine_counts[mine_count] = mine_counts.get(mine_count, 0) + weight

        # Normalize it (divide by total weights)
        total_weights = sum(self.solution_weights)
        mine_counts_normalized = {count: weight / total_weights
                                  for count, weight in mine_counts.items()}

        return mine_counts_normalized

    def __str__(self):
        output = f"Cluster with {len(self.groups)} group(s) "
        output += f"and {len(self.cells_set)} cell(s): {self.cells_set}"
        return output


class AllClusters:
    ''' Class that holds all clusters and leftovers data
    '''

    def __init__(self, covered_cells, remaining_mines, game):
        # List of all clusters
        self.clusters = []

        # Cells that are not in any cluster
        self.leftover_cells = set()

        # Mine count and chances in leftover cells
        self.leftover_mines_chances = {}

        # Average chance of a mine in leftover cells (None if NA)
        self.leftover_mine_chance = None

        # Bring these two from the solver object
        self.covered_cells = covered_cells
        self.remaining_mines = remaining_mines

        # And a helper from solver class
        self.game = game

    def calculate_all(self):
        '''Perform all cluster-related calculations: solve clusters,
        calculate weights and mine frequencies etc.
        '''
        for cluster in self.clusters:

            # Solve the cluster, including weights,
            # frequencies and probable mines
            cluster.solve_cluster(self.remaining_mines)
            cluster.calculate_solution_weights(self.covered_cells,
                                               self.remaining_mines)
            cluster.calculate_frequencies()
            cluster.possible_mine_counts()

    def calculate_leftovers(self):
        '''Based on clusters, calculate mines and probabilities in cells
        that don't belong to any clusters (leftovers).
        '''
        # Rarely, there are no clusters (when covered area is walled off
        # by mines, for example, like last 8)
        if not self.clusters:
            return

        # Collect all cells and mine estimations from all clusters
        cells_in_clusters = set()
        cross_mines = None

        # First, collect all cells that don't belong to any cluster
        for cluster in self.clusters:
            cells_in_clusters = cells_in_clusters.union(cluster.cells_set)
        self.leftover_cells = set(self.covered_cells).\
            difference(cells_in_clusters)

        # If no unaccounted cells - can't do anything
        if not self.leftover_cells:
            return

        # Next, calculate accounted mines and solutions for all cluster's
        # cross-matching. That is, all mines in all clusters: all
        # solutions where we have that many mines
        for cluster in self.clusters:

            # Calculate all possible mine counts in clusters and the number
            # of solutions permutations foreach count
            if cross_mines is None:
                cross_mines = cluster.probable_mines.copy()
            else:
                new_cross_mines = {}
                # These two loops allows to cross-check all clusters and
                # have a list of all permutations (where mines are added
                # and mine counts multiplied)
                for already_mines, already_count in cross_mines.items():
                    for mines, count in cluster.probable_mines.items():
                        new_cross_mines[already_mines + mines] = \
                            already_count * count
                cross_mines = new_cross_mines

        # Weight of each mine count: number of possible combinations
        # in the leftover cells.
        # Last line here is case there are permutations that exceed
        # the total number of remaining mines
        leftover_mines_counts = \
            {self.remaining_mines - mines:
             math.comb(len(self.leftover_cells),
                       self.remaining_mines - mines) * solutions
             for mines, solutions in cross_mines.items()
             if self.remaining_mines - mines >= 0}

        # Total weights for all leftover mine counts
        total_weights = sum(leftover_mines_counts.values())

        # If the cluster was not solved total weight would be zero.
        if total_weights == 0:
            return

        self.leftover_mines_chances = {mines: weight / total_weights
                                       for mines, weight
                                       in leftover_mines_counts.items()}

        # Total number of mines in leftover cells
        # (sum of count * probability)
        leftover_mines = sum(mines * chance
                             for mines, chance
                             in self.leftover_mines_chances.items())

        # And this is the probability of a mine in those cells
        self.leftover_mine_chance = leftover_mines / len(self.leftover_cells)

    def calculate_all_next_safe(self):
        ''' Calculate and populate "next_safe" information for each cluster
        '''
        for cluster in self.clusters:
            cluster.calculate_next_safe()

    def mines_in_leftover_part(self, cell_count):
        ''' If we take several cells (cell_count) in leftover area.
        Calculate mine counts and chances for those cells.
        '''
        overall_mine_chances = {}

        # We are looking at all possible mine counts in leftovers
        for all_leftover_mines, leftover_mines_chance in \
                self.leftover_mines_chances.items():

            # If there more mines than cells for them - ignore such option
            if len(self.leftover_cells) < all_leftover_mines:
                continue

            # Number of mines is limited by either number of cells
            # of total ines in the leftovers
            max_possible_mines = min(cell_count, all_leftover_mines) + 1
            # Then, for all possible mine counts in the part
            for mines_in_part in range(max_possible_mines):
                # Chance that there will be that many mines
                # Comb of mines in part * comb of mines in remaining part /
                # total combinations in leftover
                chance_in_part = \
                    math.comb(cell_count, mines_in_part) * \
                    math.comb(len(self.leftover_cells) - cell_count,
                              all_leftover_mines - mines_in_part) / \
                    math.comb(len(self.leftover_cells), all_leftover_mines)

                # Overall chance is a product of: 1. chance tha we have
                # mines_in_part in part 2. chance that there are
                # all_leftover_mines in leftovers
                overall_mine_chances[mines_in_part] = \
                    overall_mine_chances.get(mines_in_part, 0) + \
                    chance_in_part * leftover_mines_chance

        return overall_mine_chances

@dataclass
class CellProbability:
    ''' Data about mine probability for one cell
    '''
    # Which cell we are talking about (coordinates)
    cell: tuple

    # Which method was used to generate mine chance (for statistics)
    source: str

    # Chance this cell is a mine (0 to 1)
    mine_chance: float

    # Chance it would be an opening (no mines in surrounding cells)
    opening_chance: float = 0

    # Frontier value: how many groups is this cell a part of
    frontier: int = 0

    # How many guaranteed safe cells are there for the next move, if this
    # cell is clicked (based on CSP clusters)
    csp_next_safe: int = 0

    # Chance of having at least 1 safe (or mine) cell if this cell is clicked)
    next_move_safe_chance: float = 0

    # Expected number of safe cells for the next move
    next_safe_count: float = 0

    # Survival chance after this move and the next (calculated by going
    # through solving the field with this cell opened)
    next_survival: float = 0

    # Has this mine been shortlisted (selected for the 2nd move survival test)
    shortlisted: int = 0


class AllProbabilities():
    '''Class to work with probability-based information about cells
    Based on list (a list of CellProbability objects)
    '''

    def __init__(self):
        # Dict of AllProbabilities
        self.cells = {}
        # Same, but list (it is easier to collect data into the dict,
        # buts I will need to sort it, so I will convert it into the list)
        self.cells_list = []

    def get_luckiest(self):
        ''' Using information about mine probability ,opening probability
        and so on, return a list of cells with the best chances.
        Also, if next_moves > 0 look into future games and use chances of mine
        in the future moves. For that, use "original_solver" - it has current
        field information
        deterministic: should the solver for the next move be deterministic
        '''

        def simple_best_probability():
            ''' Calculating probability without looking into next moves:
            just pick lowest mine chance with highest opening chance.
            Return a list if several.
            '''
            # The self array of probabilities is sorted, so so the 0's
            # element has the best set of all parameters

            best_mine_chance = self.cells_list[0].mine_chance
            best_opening_chance = self.cells_list[0].opening_chance
            best_frontier = self.cells_list[0].frontier
            best_csp_next_safe = self.cells_list[0].csp_next_safe

            # Pick cells with parameters as good as the best one
            best_cells = []
            for probability_info in self.cells_list:
                if probability_info.mine_chance == best_mine_chance and \
                   probability_info.opening_chance == best_opening_chance and \
                   probability_info.frontier == best_frontier and \
                   probability_info.csp_next_safe == best_csp_next_safe:
                    best_cells.append(probability_info.cell)

            return best_cells

        # Convert dict into list, so we could sort it
        self.cells_list = list(self.cells.values())

        # Sort the cells by: chance, opening, frontier, next_safe
        self.cells_list.sort(key=lambda x: (-x.mine_chance, x.opening_chance,
                                            x.frontier, x.csp_next_safe),
                             reverse=True)

        # Simple best cells are those we can calculate without looking into
        # next move. Return them if we don't need to look into next moves
        simple_best_cells = simple_best_probability()

        return simple_best_cells

agent.py:
import pygame
from settings import *
from sprites import *
from main import Game
from MineGroup import *
import matplotlib.pyplot as plt
import numpy as np

class MinesweeperAgent:
    def __init__(self, game):
        self.game = game
        self.board = game.board
        self.remaining_mines = AMOUNT_MINES
        self.covered_tiles = ROWS * COLS
        self.groups = AllGroups()
        self.all_clusters = AllClusters(self.covered_tiles,
                                           self.remaining_mines, self.game)
        self.probability = None
        self.unaccounted_group = None
        self.bruteforce_solutions = None
        self.first_move = True
        self.last_move_info = None
        self.random_selections = 0  # Counter for random tile selections

    def generate_all_covered(self):
        ''' Populate self.covered_tiles with the list of all covered cells.
        '''
        self.covered_tiles = self.board.get_covered_tiles()

    def generate_remaining_mines(self):
        ''' Populate self.mines with the list of all mines.
        '''
        self.remaining_mines = self.board.calculate_remaining_mines()

    def generate_groups(self):
        ''' Populate self.group with MineGroup objects
        '''

        # Reset the groups
        self.groups.reset()

        # Go over all cells and find all the "Numbered ones"
        for row in self.board.board_list:
            for tile in row:

                # Groups are only for numbered cells
                if not tile.number or not tile.revealed:
                    continue

                # For them we'll need to know two things:
                # What are the uncovered cells around it
                covered_neighbors = []
                # And how many "Active" (that is, minus marked)
                # mines are still there
                active_mines = tile.number

                # Go through the neighbors
                for neighbor in self.board.get_neighbours(tile.x // TILESIZE, tile.y // TILESIZE):
                    # Collect all covered cells
                    if not neighbor.revealed and not neighbor.flagged:
                        covered_neighbors.append(neighbor)
                    # Subtract all marked mines
                    if neighbor.flagged:
                        active_mines -= 1

                # If the list of covered cells is not empty:
                # store it in the self.groups
                if covered_neighbors:
                    new_group = MineGroup(covered_neighbors, active_mines)
                    self.groups.add_group(new_group)

    def generate_clusters(self):
        ''' Initiate self.all_clusters and populate it with
        GroupCluster objects
        '''
        # Reset clusters
        self.all_clusters = AllClusters(self.covered_tiles,
                                           self.remaining_mines, self.game)
        # Reset all "belong to cluster" information from the groups
        self.groups.reset_clusters()

        # Keep going as long as there are groups not belonging to clusters
        while self.groups.next_non_clustered_groups() is not None:

            # Initiate a new cluster with such a group
            new_cluster = GroupCluster(
                self.groups.next_non_clustered_groups())

            while True:

                # Look through all groups
                for group in self.groups.exact_groups():
                    # If it overlaps with this group and not part of any
                    # other cluster - add this group
                    if group.belong_to_cluster is None and \
                       new_cluster.overlap(group):
                        new_cluster.add_group(group)
                        break

                # We went through the groups without adding any:
                # new_cluster is done
                else:
                    self.all_clusters.clusters.append(new_cluster)
                    # Exit the while loop
                    break

    def generate_unaccounted(self):
        ''' Populate self.unaccounted_group with a MineGroup made of cells
        and mines from "unknown" area, that is NOT next to any number.
        Used in "Coverage" method and in mine probability calculations.
        '''

        def coverage_attempt(accounted_cells, accounted_mines):
            ''' Create a coverage (set of non-overlapping mine groups),
            given cells and mines that are already in the coverage.
            Uses greedy method to maximize the number of cells in the coverage
            '''

            while True:
                # The idea is to find a group that has a largest number of
                # unaccounted cells
                best_count = None
                best_group = None
                for group in self.groups.exact_groups():

                    # If group overlaps with what we have so far -
                    # we don't need such group
                    if accounted_cells.intersection(group.cells):
                        continue

                    # Find the biggest group that we haven't touched yet
                    if best_count is None or len(group.cells) > best_count:
                        best_count = len(group.cells)
                        best_group = group

                # We have a matching group
                if best_group is not None:
                    # Cells from that group from now on are accounted for
                    accounted_cells = accounted_cells.union(best_group.cells)
                    # And so are  mines
                    accounted_mines += best_group.mines
                # No such  group was found: coverage is done
                else:
                    break

            return accounted_cells, accounted_mines

        # Reset the final variable
        self.unaccounted_group = None

        # This method usually has no effect in the beginning of the game.
        # Highest count of remaining cells when it worked was at 36-37.
        if len(self.covered_tiles) > 40:
            return

        # Generate several coverage options.
        # Put them into coverage_options
        coverage_options = []
        # FOr each option we are going to start with different group,
        # and then proceed with greedy algorithm
        for group in self.groups:
            initial_cells = set(group.cells)
            initial_mines = group.mines
            coverage_option_cells, coverage_option_mines = \
                coverage_attempt(initial_cells, initial_mines)
            coverage_options.append((coverage_option_cells,
                                     coverage_option_mines))

        if not coverage_options:
            return

        # Sort them by the number of cells in coverage
        # Choose the one with the most cells
        coverage_options.sort(key=lambda x: len(x[0]), reverse=True)
        accounted_cells, accounted_mines = coverage_options[0]

        # unaccounted cells are all minus accounted
        unaccounted_cells = set(self.covered_tiles).difference(accounted_cells)
        # Same with mines
        unaccounted_mines = self.remaining_mines - accounted_mines

        # Those unaccounted mines can now for a new  group
        self.unaccounted_group = MineGroup(unaccounted_cells,
                                              unaccounted_mines)

    def method_groups(self):
        ''' Method #2. Groups.
        Cross check all groups. When group is a subset of
        another group, try to deduce safe cells and mines.
        '''
        safe, mines = [], []

        # Cross-check all-with-all groups
        for group_a in self.groups:
            for group_b in self.groups:

                # Don't compare with itself
                if group_a.hash == group_b.hash:
                    continue

                safe.extend(self.deduce_safe(group_a, group_b))
                mines.extend(self.deduce_mines(group_a, group_b))

                # If group A is a subset of group B and B has more mines
                # we can create a new group that would contain
                # B-A cells and B-A mines
                # len(group_b.cells) < 8 prevents computational explosion on
                # multidimensional fields
                if len(group_b.cells) < 8 and \
                   group_a.cells.issubset(group_b.cells) and \
                   group_b.mines - group_a.mines > 0:
                    new_group = MineGroup(group_b.cells - group_a.cells,
                                             group_b.mines - group_a.mines)
                    self.groups.add_group(new_group)

        return list(set(safe))
    
    def method_csp(self):
        ''' Method #4. CSP (Constraint Satisfaction Problem).
        Generate overlapping groups (clusters). For each cluster find safe
        cells and mines by brute forcing all possible solutions.
        '''
        safe, mines = [], []

        # Generate clusters
        self.generate_clusters()
        # Do all the solving / calculate frequencies stuff
        self.all_clusters.calculate_all()

        for cluster in self.all_clusters.clusters:

            # Get safe cells and mines from cluster
            safe.extend(cluster.safe_cells())
            mines.extend(cluster.mine_cells())
        return list(set(safe))

    def calculate_probabilities(self):
        ''' Final method. "Probability". Use various methods to determine
        which cell(s) is least likely to have a mine
        '''

        def background_probabilities(self):
            ''' Populate self.probabilities based on background probability.
            Which is All mines divided by all covered cells.
            It is quite crude and often inaccurate, it is just a fallback
            if any of more accurate methods don't work.
            '''
            background_probability = \
                self.remaining_mines / len(self.covered_tiles)

            for cell in self.covered_tiles:
                self.probability.cells[cell] = \
                    CellProbability(cell, "Background",
                                       background_probability)

        def probabilities_for_groups(self):
            ''' Update self.probabilities, based on mine groups.
            For each group consider mine probability as "number of mines
            divided by the number of cells".
            '''
            for group in self.groups.exact_groups():

                # Probability of each mine in the group
                group_probability = group.mines / len(group.cells)
                for cell in group.cells:

                    # If group's probability is higher than the background:
                    # Overwrite the probability result
                    if group_probability > \
                       self.probability.cells[cell].mine_chance:
                        self.probability.cells[cell] = \
                            CellProbability(cell, "Groups",
                                               group_probability)

        def csp_probabilities(self):
            ''' Update self.probabilities based on results from CSP method.
            '''
            for cluster in self.all_clusters.clusters:
                for cell, frequency in cluster.frequencies.items():
                    # Overwrite the probability result
                    self.probability.cells[cell] = \
                        CellProbability(cell, "CSP", frequency)

        # Reset probabilities
        self.probability = AllProbabilities()
        # Background probability: all remaining mines on all covered cells
        background_probabilities(self)
        # Based on mines in groups
        probabilities_for_groups(self)
        # Based on CSP solutions
        csp_probabilities(self)

    def calculate_opening_chances(self):
        ''' Populate opening_chance in self.probabilities: a chance that this
        cell is a zero. (Which is a good thing)
        '''
        # Go through all cells we have probability info for
        # (that would be all covered cells)
        for cell, cell_info in self.probability.cells.items():
            zero_chance = 1
            # Look at neighbors of each cell
            for neighbor in self.board.get_neighbours(cell.x // TILESIZE, cell.y // TILESIZE):
                # If there are any mines around, there is no chance of opening
                if neighbor.flagged:
                    cell_info.opening_chance = 0
                    break
                # Otherwise each mine chance decrease opening chance
                # by (1 - mine chance) times
                if neighbor in self.probability.cells:
                    zero_chance *= \
                        (1 - self.probability.cells[neighbor].mine_chance)
            else:
                self.probability.cells[cell].opening_chance = zero_chance

    def calculate_frontier(self):
        ''' Populate frontier (how many groups may be affected by this cell)
        '''
        # Generate frontier
        self.groups.generate_frontier()

        for cell in self.groups.frontier:
            for neighbors in self.board.get_neighbours(cell.x // TILESIZE, cell.y // TILESIZE):
                if neighbors in self.probability.cells:
                    self.probability.cells[neighbors].frontier += 1

    def calculate_next_safe_csp(self):
        ''' Populate "next safe" information (how many guaranteed safe cells
        will be in the next move, based on CSP solutions).
        '''
        # Do the calculations
        self.all_clusters.calculate_all_next_safe()

        # Populate probability object with this info
        for cluster in self.all_clusters.clusters:
            for cell, next_safe in cluster.next_safe.items():
                self.probability.cells[cell].csp_next_safe = next_safe

    def make_decision(self):
        safe_tiles = []
        # self.board.display_board()
        if self.first_move:
            self.first_move = False
            return [self.board.board_list[0][0]]
        else:
            self.find_mines()
            # self.board.display_board()
            safe_tiles = self.basic()
            if safe_tiles:
                self.last_move_info = ("Naive", None, None)
            if not safe_tiles:
                # print("Using CSP...")
                self.last_move_info = ("CSP", None, None)
                safe_tiles = self.method_csp()
            if not safe_tiles:
                # Calculate mine probability using various methods
                self.calculate_probabilities()
                # Calculate safe cells for the next move in CSP
                self.calculate_next_safe_csp()

                # Two more calculations that will be used to pick
                # the best random cell:
                # Opening chances (chance that cell is a zero)
                self.calculate_opening_chances()
                # Does it touch a frontier (cells that already are in groups)
                self.calculate_frontier()

                lucky_cells = self.probability.get_luckiest()
                if lucky_cells:
                    self.random_selections += 1
                    return [lucky_cells[0]]
                self.last_move_info = ("Last Resort", None, None)
                return [self.board.get_random_unrevealed_tile()]
            # print(f"Safe tiles: {[(tile.x // TILESIZE, tile.y // TILESIZE) for tile in safe_tiles]}")
            return safe_tiles


    def play(self):
        self.generate_all_covered()
        self.generate_remaining_mines()
        self.generate_groups()
        self.generate_unaccounted()
        tiles = self.make_decision()
        for tile in tiles:
            self.game.draw()  # Draw the board
            # pygame.display.flip()  # Update the display
            # waiting = True
            # while waiting:  # Wait for the Enter key to be pressed
            #     for event in pygame.event.get():
            #         if event.type == pygame.QUIT:
            #             pygame.quit()
            #         if event.type == pygame.KEYDOWN:
            #             if event.key == pygame.K_RETURN:
            #                 waiting = False
            self.game.run(tile)
    
    def find_mines(self):
        for row in range(ROWS):
            for col in range(COLS):
                tile = self.board.board_list[row][col]
                unrevealed_neighbors = [neighbour for neighbour in self.board.get_neighbours(row, col) if not neighbour.revealed]
                if tile.number == len(unrevealed_neighbors):
                    for mine in unrevealed_neighbors:
                        mine.flagged = True

    def basic(self):
        for row in range(ROWS):
            for col in range(COLS):
                tile = self.board.board_list[row][col]
                if tile.number:
                    unrevealed_neighbors = [neighbour for neighbour in self.board.get_neighbours(row, col) if not neighbour.revealed]
                    flagged_neighbors = [neighbour for neighbour in unrevealed_neighbors if neighbour.flagged]
                    if tile.number == len(flagged_neighbors) and len(unrevealed_neighbors) > len(flagged_neighbors):
                        return [neighbour for neighbour in unrevealed_neighbors if not neighbour.flagged]

# Main game loop with the agent
if __name__ == "__main__":
    pygame.init()
    random.seed(1)
    wins = 0  # Counter for wins
    losses = 0  # Counter for losses
    total_random_selections = 0  # Counter for total random tile selections

    for i in range(50):  # Play 100 games
        game = Game()
        game.new()
        agent = MinesweeperAgent(game)
        print(f"Game {i + 1}")
        while game.playing:
            agent.play()
            if not game.playing:
                break

        if game.win:  # If the game was won, increment the wins counter
            wins += 1
        else:  # If the game was lost, increment the losses counter
            losses += 1

        total_random_selections += agent.random_selections  # Add the number of random tile selections in this game to the total

    win_percentage = (wins / (wins + losses)) * 100 if (wins + losses) > 0 else 0  # Calculate the win percentage, avoid division by zero
    average_random_selections = total_random_selections / 100  # Calculate the average number of random choices per game

    print("{:<20} {:<10} {:<10} {:<20} {:<25}".format('Wins', 'Losses', 'Win %', 'Total Random Selections', 'Avg Random Selections'))  # Print the table headers
    print("{:<20} {:<10} {:<10.2f} {:<20} {:<25.2f}".format(wins, losses, win_percentage, total_random_selections, average_random_selections))  # Print the table data

    pygame.quit()